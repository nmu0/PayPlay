"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.lintFile = void 0;
var typescript_1 = require("typescript");
var types_1 = require("./types");
// Determines if this is a test file.
var isTestFile = function (file) {
    return file.fileName.endsWith("_test.ts") ||
        file.fileName.endsWith("_test.tsx");
};
// Determines whether this is a ++var, --var, var++, or var--.
var isVariableIncDec = function (expr) {
    if (expr.kind === typescript_1.SyntaxKind.PrefixUnaryExpression) {
        if ((0, types_1.assertPrefixUnaryExpr)(expr)) {
            return (expr.operator === typescript_1.SyntaxKind.PlusPlusToken ||
                expr.operator === typescript_1.SyntaxKind.MinusMinusToken) &&
                expr.operand.kind === typescript_1.SyntaxKind.Identifier;
        }
    }
    else if (expr.kind === typescript_1.SyntaxKind.PostfixUnaryExpression) {
        if ((0, types_1.assertPostfixUnaryExpr)(expr)) {
            return (expr.operator === typescript_1.SyntaxKind.PlusPlusToken ||
                expr.operator === typescript_1.SyntaxKind.MinusMinusToken) &&
                expr.operand.kind === typescript_1.SyntaxKind.Identifier;
        }
    }
    return false;
};
/**
 * Lints the contents of the given file.
 * @param file File to lint
 */
var lintFile = function (file) {
    file.root.forEachChild(function (node) { return lintTopLevelNode(file, node); });
};
exports.lintFile = lintFile;
// Lints the given child of the source file.
var lintTopLevelNode = function (file, node) {
    switch (node.kind) {
        case typescript_1.SyntaxKind.ImportDeclaration:
            if ((0, types_1.assertImportDecl)(node)) {
                lintImportDecl(file, node);
            }
            break;
        case typescript_1.SyntaxKind.EndOfFileToken:
            // OK
            break;
        case typescript_1.SyntaxKind.TypeAliasDeclaration:
            if ((0, types_1.assertTypeAliasDecl)(node)) {
                lintTypeAliasDecl(file, node);
            }
            break;
        case typescript_1.SyntaxKind.VariableStatement:
            if ((0, types_1.assertVariableStmt)(node)) {
                lintVariableStmt(file, node, true, false);
            }
            break;
        case typescript_1.SyntaxKind.ExpressionStatement:
            if ((0, types_1.assertExpressionStmt)(node)) {
                lintExpressionStmt(file, node, false);
            }
            break;
        case typescript_1.SyntaxKind.IfStatement:
            if ((0, types_1.assertIfStmt)(node)) {
                lintIfStmt(file, node, false);
            }
            break;
        case typescript_1.SyntaxKind.SwitchStatement:
            if ((0, types_1.assertSwitchStmt)(node)) {
                lintSwitchStmt(file, node, false);
            }
            break;
        case typescript_1.SyntaxKind.WhileStatement:
            if ((0, types_1.assertWhileStmt)(node)) {
                lintWhileStmt(file, node, false);
            }
            break;
        case typescript_1.SyntaxKind.ForStatement:
            if ((0, types_1.assertForStmt)(node)) {
                lintForStmt(file, node, false);
            }
            break;
        case typescript_1.SyntaxKind.ForOfStatement:
            if ((0, types_1.assertForOfStmt)(node)) {
                lintForOfStmt(file, node, false);
            }
            break;
        case typescript_1.SyntaxKind.ReturnStatement:
            if ((0, types_1.assertReturnStmt)(node)) {
                lintReturnStmt(file, node, false);
            }
            break;
        case typescript_1.SyntaxKind.ThrowStatement:
            if ((0, types_1.assertThrowStmt)(node)) {
                lintThrowStmt(file, node, false);
            }
            break;
        case typescript_1.SyntaxKind.TryStatement:
            if ((0, types_1.assertTryStmt)(node)) {
                lintTryStmt(file, node, false);
            }
            break;
        case typescript_1.SyntaxKind.DoStatement:
            if ((0, types_1.assertDoStmt)(node)) {
                file.error("do statements are not allowed", node.statement.pos - 2);
            }
            break;
        case typescript_1.SyntaxKind.ForInStatement:
            if ((0, types_1.assertForInStmt)(node)) {
                file.error("for-in statements are not allowed", node.expression.pos, node.expression.end);
            }
            break;
        case typescript_1.SyntaxKind.WithStatement:
            if ((0, types_1.assertWithStmt)(node)) {
                file.error("with statements are not allowed", node.expression.pos, node.expression.end);
            }
            break;
        case typescript_1.SyntaxKind.LabeledStatement:
            if ((0, types_1.assertLabeledStmt)(node)) {
                file.error("labeled statements are not allowed", node.label.end - 1);
            }
            break;
        case typescript_1.SyntaxKind.Block:
            if ((0, types_1.assertBlock)(node)) {
                lintBlock(file, node, false);
            }
            break;
        case typescript_1.SyntaxKind.FunctionDeclaration:
            if ((0, types_1.assertFunctionDecl)(node)) {
                if (node.name === undefined) {
                    file.error("incorrect syntax for a function declaration", node.parameters.pos);
                }
                else {
                    file.error("incorrect syntax for a function declaration", node.name.pos);
                }
            }
            break;
        case typescript_1.SyntaxKind.InterfaceDeclaration:
            if ((0, types_1.assertInterfaceDecl)(node)) {
                lintInterfaceDecl(file, node);
            }
            break;
        case typescript_1.SyntaxKind.ClassDeclaration:
            if ((0, types_1.assertClassDecl)(node)) {
                lintClassDecl(file, node);
            }
            break;
        case typescript_1.SyntaxKind.ModuleDeclaration:
            // Used in saferoutes.ts. We allow it to go through
            break;
        default:
            file.error("unexpected top-level node type: ".concat(typescript_1.SyntaxKind[node.kind]), node.pos + 1);
            break;
    }
};
// Set of imports that can be used with "import name as 'name'" syntax.
var allowedNameImports = new Set(["express", "body-parser", "react"]);
// Set of imports that can be used with "import * from name as 'name'" syntax.
var allowedStarImports = new Set(["assert", "node-mocks-http"]);
/** Determines if the given name could be an image file. */
var isImageName = function (name) {
    name = name.toLowerCase();
    return name.endsWith(".png") || name.endsWith(".jpg") || name.endsWith(".jpeg") ||
        name.endsWith(".gif") || name.endsWith(".svg");
};
// Performs linting of an import statement.
var lintImportDecl = function (file, node) {
    if (node.importClause === undefined) {
        // OK (this is probably a CSS import)
    }
    else {
        if (node.importClause.namedBindings !== undefined &&
            node.importClause.namedBindings.kind === typescript_1.SyntaxKind.NamedImports) {
            // OK (regular import)
        }
        else if (node.importClause.name !== undefined &&
            node.importClause.name.kind === typescript_1.SyntaxKind.Identifier &&
            node.moduleSpecifier !== undefined &&
            node.moduleSpecifier.kind === typescript_1.SyntaxKind.StringLiteral) {
            if ((0, types_1.assertStringLiteral)(node.moduleSpecifier)) {
                if (!allowedNameImports.has(node.moduleSpecifier.text) &&
                    !isImageName(node.moduleSpecifier.text)) {
                    file.error("unexpected import of ".concat(node.moduleSpecifier.text), node.importClause.pos);
                }
            }
        }
        else if (node.importClause.namedBindings !== undefined &&
            node.importClause.namedBindings.kind === typescript_1.SyntaxKind.NamespaceImport &&
            node.moduleSpecifier !== undefined &&
            node.moduleSpecifier.kind === typescript_1.SyntaxKind.StringLiteral) {
            if ((0, types_1.assertStringLiteral)(node.moduleSpecifier)) {
                if (!allowedStarImports.has(node.moduleSpecifier.text)) {
                    file.error("unexpected * import of ".concat(node.moduleSpecifier.text), node.importClause.pos);
                }
            }
        }
        else {
            file.error("unexpected import syntax", node.importClause.pos);
        }
    }
};
// Performs linting of a type alias declaration.
var lintTypeAliasDecl = function (file, node) {
    lintType(file, node.type, true);
};
// Performs linting of an interface declaration.
var lintInterfaceDecl = function (file, node) {
    var e_1, _a, e_2, _b;
    try {
        for (var _c = __values(node.members), _d = _c.next(); !_d.done; _d = _c.next()) {
            var member = _d.value;
            if (member.kind === typescript_1.SyntaxKind.PropertySignature) {
                if ((0, types_1.assertPropertySignature)(member)) {
                    if (member.type === undefined) {
                        file.error("field declaration is missing a type", member.name.end - 1);
                    }
                    else {
                        if (member.type.kind !== typescript_1.SyntaxKind.FunctionType) {
                            file.error("interfaces can only contain methods", member.name.end - 1);
                        }
                        else {
                            if ((0, types_1.assertFunctionType)(member.type)) {
                                try {
                                    for (var _e = (e_2 = void 0, __values(member.type.parameters)), _f = _e.next(); !_f.done; _f = _e.next()) {
                                        var param = _f.value;
                                        if (param.type === undefined) {
                                            file.error("parameter is missing a type", param.name.end - 1);
                                        }
                                        else {
                                            lintType(file, param.type);
                                        }
                                    }
                                }
                                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                                finally {
                                    try {
                                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                                    }
                                    finally { if (e_2) throw e_2.error; }
                                }
                                lintType(file, member.type.type);
                            }
                        }
                    }
                }
            }
            else if (member.kind === typescript_1.SyntaxKind.MethodSignature) {
                if ((0, types_1.assertMethodSignature)(member)) {
                    file.error("incorrect method declaration syntax", member.name.end - 1);
                }
            }
            else {
                file.error("unexpected interface member type: ".concat(typescript_1.SyntaxKind[member.kind]), member.pos + 1);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
};
// Performs linting of an class declaration.
var lintClassDecl = function (file, node) {
    var e_3, _a;
    var superclass = undefined;
    var interfaces = [];
    if (node.heritageClauses !== undefined) {
        try {
            for (var _b = __values(node.heritageClauses), _c = _b.next(); !_c.done; _c = _b.next()) {
                var herit = _c.value;
                if (herit.types.length === 1 &&
                    herit.types[0].expression.kind === typescript_1.SyntaxKind.Identifier &&
                    (0, types_1.assertIdentifier)(herit.types[0].expression)) {
                    if (herit.token === typescript_1.SyntaxKind.ExtendsKeyword) {
                        superclass = herit.types[0].expression.text;
                    }
                    else if (herit.token === typescript_1.SyntaxKind.ImplementsKeyword) {
                        interfaces.push(herit.types[0].expression.text);
                    }
                    else {
                        file.error("unexpected inheritance token: ".concat(typescript_1.SyntaxKind[herit.token]), herit.pos + 1);
                    }
                }
                else {
                    file.error("incorrect inheritance syntax", herit.pos + 1);
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
    }
    if (superclass === "Component") {
        lintComponentClass(file, node, interfaces);
    }
    else {
        lintAdtClass(file, node, superclass, interfaces);
    }
};
// Performs linting of a UI component.
var lintComponentClass = function (file, node, interfaces) {
    var e_4, _a;
    if (interfaces.length > 0) {
        file.error("components should not implement any interfaces", node.name !== undefined ? node.name.pos : node.pos + 1);
    }
    try {
        for (var _b = __values(node.members), _c = _b.next(); !_c.done; _c = _b.next()) {
            var member = _c.value;
            switch (member.kind) {
                case typescript_1.SyntaxKind.Constructor:
                    if ((0, types_1.assertConstructorDecl)(member)) {
                        lintConstructor(file, member);
                    }
                    break;
                case typescript_1.SyntaxKind.PropertyDeclaration:
                    if ((0, types_1.assertPropertyDecl)(member)) {
                        if (member.initializer !== undefined &&
                            member.initializer.kind === typescript_1.SyntaxKind.ArrowFunction &&
                            (0, types_1.assertArrowFunction)(member.initializer)) {
                            var name_1 = getName(member.name);
                            if (name_1 !== undefined) {
                                lintComponentMethodName(file, member.name, name_1);
                            }
                            else {
                                file.error("unexpected property name syntax: ".concat(typescript_1.SyntaxKind[member.name.kind]), member.name.end);
                            }
                            lintArrowFunction(file, member.initializer, false);
                        }
                        else {
                            file.error("fields are not allowed in components", member.name.end - 1);
                        }
                    }
                    break;
                case typescript_1.SyntaxKind.MethodDeclaration:
                    if ((0, types_1.assertMethodDecl)(member)) {
                        file.error("incorrect method declaration syntax", member.name.end - 1);
                    }
                    break;
                default:
                    file.error("unexpected class member type: ".concat(typescript_1.SyntaxKind[member.kind]), member.pos + 1);
                    break;
            }
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_4) throw e_4.error; }
    }
};
// Set of allowed lifecycle methods.
var allowedLifeCycleMethods = new Set(["componentDidMount", "componentDidUpdate", "componentWillUnmount"]);
// Set of allowed HTML events.
// TODO: add more
var allowedEvents = new Set([
    "Click", "Change", "Timeout", "Focus", "Blur", "MouseEnter", "MouseLeave",
    "KeyDown", "KeyUp", "KeyPress", "Fetch", "Resp", "Response", "Json",
    "Error"
]);
// Performs linting of the name of a component method
var lintComponentMethodName = function (file, node, name) {
    var e_5, _a;
    if (name.startsWith("render") &&
        (name.length === 6 || name[6].toUpperCase() === name[6])) {
        // OK: render or render helper
    }
    else if (name.startsWith("get") &&
        name.length > 3 && name[3].toUpperCase() === name[3]) {
        // OK: getter function
    }
    else if (name.startsWith("set") &&
        name.length > 3 && name[3].toUpperCase() === name[3]) {
        // OK: setter function
    }
    else if (allowedLifeCycleMethods.has(name)) {
        // OK
    }
    else {
        if (!name.startsWith("do") || name.length < 3 ||
            name[2].toUpperCase() !== name[2]) {
            file.error("event handler method names must start with 'do'", node.end - 1);
        }
        else {
            try {
                for (var allowedEvents_1 = __values(allowedEvents), allowedEvents_1_1 = allowedEvents_1.next(); !allowedEvents_1_1.done; allowedEvents_1_1 = allowedEvents_1.next()) {
                    var evtName = allowedEvents_1_1.value;
                    if (name.endsWith(evtName)) {
                        return; // OK
                    }
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (allowedEvents_1_1 && !allowedEvents_1_1.done && (_a = allowedEvents_1.return)) _a.call(allowedEvents_1);
                }
                finally { if (e_5) throw e_5.error; }
            }
            file.error("event handler method names must end with an event name (e.g., Click)", node.end);
        }
    }
};
// Performs linting of a class that implements an ADT.
var lintAdtClass = function (file, node, superclass, interfaces) {
    var e_6, _a;
    if (node.modifiers !== undefined &&
        contains(node.modifiers, typescript_1.SyntaxKind.ExportKeyword)) {
        file.error("classes cannot be exported", node.modifiers.pos);
    }
    if (superclass !== undefined) {
        file.error("inheritance is not allowed", node.name !== undefined ? node.name.end - 1 : node.pos + 1);
    }
    if (interfaces.length === 0) {
        file.error("classes must implement some interface", node.name !== undefined ? node.name.end - 1 : node.pos + 1);
    }
    try {
        for (var _b = __values(node.members), _c = _b.next(); !_c.done; _c = _b.next()) {
            var member = _c.value;
            switch (member.kind) {
                case typescript_1.SyntaxKind.Constructor:
                    if ((0, types_1.assertConstructorDecl)(member)) {
                        lintConstructor(file, member);
                    }
                    break;
                case typescript_1.SyntaxKind.PropertyDeclaration:
                    if ((0, types_1.assertPropertyDecl)(member)) {
                        if (member.initializer === undefined) {
                            if (member.type === undefined) {
                                file.error("field is missing a type", member.name.end - 1);
                            }
                            else {
                                lintType(file, member.type);
                            }
                        }
                        else {
                            if (member.initializer.kind === typescript_1.SyntaxKind.ArrowFunction &&
                                (0, types_1.assertArrowFunction)(member.initializer)) {
                                lintArrowFunction(file, member.initializer, false);
                            }
                            else {
                                lintExpression(file, member.initializer, false);
                            }
                        }
                    }
                    break;
                case typescript_1.SyntaxKind.MethodDeclaration:
                    if ((0, types_1.assertMethodDecl)(member)) {
                        file.error("incorrect method declaration syntax", member.name.end - 1);
                    }
                    break;
                default:
                    file.error("unexpected class member type: ".concat(typescript_1.SyntaxKind[member.kind]), member.pos + 1);
                    break;
            }
        }
    }
    catch (e_6_1) { e_6 = { error: e_6_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_6) throw e_6.error; }
    }
};
// Performs linting of a constructor declaration.
var lintConstructor = function (file, node) {
    var e_7, _a;
    try {
        for (var _b = __values(node.parameters), _c = _b.next(); !_c.done; _c = _b.next()) {
            var param = _c.value;
            if (param.type === undefined) {
                file.error("parameters must have types", param.name.end - 1);
            }
            else {
                lintType(file, param.type);
            }
        }
    }
    catch (e_7_1) { e_7 = { error: e_7_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_7) throw e_7.error; }
    }
    if (node.body === undefined) {
        file.error("constructor is missing a body", node.name !== undefined ? node.name.end - 1 : node.pos + 1);
    }
    else {
        lintBlock(file, node.body, true);
    }
};
// Performs linting of a *top-level* variable statement.
var lintVariableStmt = function (file, node, topLevel, isConstructor) {
    if (node.modifiers !== undefined &&
        contains(node.modifiers, typescript_1.SyntaxKind.ExportKeyword) &&
        !(0, types_1.hasJSDoc)(node)) {
        file.error("exported declarations must have a JSDoc comment", (node.declarationList.declarations.length === 0) ? node.pos + 1 :
            node.declarationList.declarations[0].name.end - 1);
    }
    lintVariableDecl(file, node.declarationList, topLevel, false, isConstructor);
};
// Performs linting of a variable declaration.
var lintVariableDecl = function (file, list, topLevel, reqInitalizer, isConstructor) {
    if (!file.allowMutation && (list.flags & typescript_1.NodeFlags.Const) === 0) {
        file.error("all variable declarations must be const (no mutation)", (list.declarations.length === 0) ? list.pos + 1 :
            list.declarations[0].name.end - 1);
    }
    if ((list.flags & typescript_1.NodeFlags.Const) === 0 && (list.flags & typescript_1.NodeFlags.Let) === 0) {
        file.error("variables can only be declared with let or const (no var)", (list.declarations.length === 0) ? list.pos + 1 :
            list.declarations[0].name.end - 1);
    }
    if (list.declarations.length !== 1) {
        file.error("expected exactly one variable declaration", list.declarations.pos + 1);
    }
    else {
        var decl = list.declarations[0];
        lintBindingName(file, decl.name);
        if (decl.initializer === undefined) {
            if (reqInitalizer) {
                file.error("must be initialized", decl.name.end - 1);
            }
        }
        else if (topLevel && decl.initializer.kind === typescript_1.SyntaxKind.ArrowFunction) {
            if ((0, types_1.assertArrowFunction)(decl.initializer)) {
                lintArrowFunction(file, decl.initializer, isConstructor);
            }
        }
        else {
            if (decl.type === undefined) {
                if (topLevel) {
                    file.error("top-level variable declarations must have a type", decl.name.end - 1);
                }
            }
            else {
                lintType(file, decl.type);
            }
            lintExpression(file, decl.initializer, isConstructor);
        }
    }
};
// Performs linting of a binding name.
var lintBindingName = function (file, name) {
    var e_8, _a;
    if (name.kind === typescript_1.SyntaxKind.Identifier) {
        // OK
    }
    else if (name.kind === typescript_1.SyntaxKind.ArrayBindingPattern) {
        if ((0, types_1.assertArrayBindingPattern)(name)) {
            try {
                for (var _b = __values(name.elements), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var elem = _c.value;
                    if (elem.kind === typescript_1.SyntaxKind.BindingElement) {
                        if ((0, types_1.assertBindingElement)(elem)) {
                            lintBindingName(file, elem.name);
                        }
                    }
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_8) throw e_8.error; }
            }
        }
    }
    else { // object binding pattern
        file.error("record destructuring is not allowed", name.end - 1);
    }
};
// Determines whether the given array of modifiers contains the kind.
var contains = function (mods, kind) {
    for (var i = 0; i < mods.length; i++) {
        if (mods[i].kind === kind) {
            return true;
        }
    }
    return false;
};
// Performs linting of an arrow function.
var lintArrowFunction = function (file, node, isConstructor) {
    var e_9, _a;
    var paramTypes = [];
    try {
        for (var _b = __values(node.parameters), _c = _b.next(); !_c.done; _c = _b.next()) {
            var param = _c.value;
            if (param.type === undefined) {
                file.error("parameters must have types", param.name.end - 1);
            }
            else if (param.initializer !== undefined) {
                file.error("parameters cannot have default values", param.name.end - 1);
            }
            else {
                lintType(file, param.type);
                paramTypes.push(param.type);
            }
        }
    }
    catch (e_9_1) { e_9 = { error: e_9_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_9) throw e_9.error; }
    }
    if (node.type === undefined) {
        file.error("functions must have a return type", node.parameters.end + 1);
    }
    else {
        lintType(file, node.type);
    }
    // For .ts files: if the two argument types are (Safe)Request and
    // (Safe)Response, then make sure they are both declared as the safe variants.
    if (paramTypes.length === 2) {
        var paramType0 = paramTypes[0];
        var paramType1 = paramTypes[1];
        if (paramType0.kind === typescript_1.SyntaxKind.TypeReference &&
            paramType1.kind === typescript_1.SyntaxKind.TypeReference) {
            if ((0, types_1.assertTypeReference)(paramType0) &&
                (0, types_1.assertTypeReference)(paramType1)) {
                if (paramType0.typeName.kind === typescript_1.SyntaxKind.Identifier &&
                    paramType1.typeName.kind === typescript_1.SyntaxKind.Identifier) {
                    if ((paramType0.typeName.text === "Request" ||
                        paramType0.typeName.text === "SafeRequest") &&
                        (paramType1.typeName.text === "Response" ||
                            paramType1.typeName.text === "SafeResponse") &&
                        file.fileName.endsWith(".ts")) {
                        if (paramType0.typeName.text !== "SafeRequest") {
                            file.error("must use SafeRequest and SafeResponse", paramType0.typeName.end - 1);
                        }
                        if (paramType1.typeName.text !== "SafeResponse") {
                            file.error("must use SafeRequest and SafeResponse", paramType1.typeName.end - 1);
                        }
                    }
                }
            }
        }
    }
    if (node.body.kind === typescript_1.SyntaxKind.Block) {
        if ((0, types_1.assertBlock)(node.body)) {
            lintBlock(file, node.body, isConstructor);
        }
    }
    else {
        lintExpression(file, node.body, isConstructor);
    }
};
// Performs lintinig of a block.
var lintBlock = function (file, node, isConstructor) {
    var e_10, _a;
    try {
        for (var _b = __values(node.statements), _c = _b.next(); !_c.done; _c = _b.next()) {
            var stmt = _c.value;
            lintStatement(file, stmt, isConstructor);
        }
    }
    catch (e_10_1) { e_10 = { error: e_10_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_10) throw e_10.error; }
    }
};
// Lints the given statement inside a function.
var lintStatement = function (file, node, isConstructor) {
    switch (node.kind) {
        case typescript_1.SyntaxKind.EmptyStatement:
        case typescript_1.SyntaxKind.DebuggerStatement:
        case typescript_1.SyntaxKind.ContinueStatement:
        case typescript_1.SyntaxKind.BreakStatement:
            break;
        case typescript_1.SyntaxKind.VariableStatement:
            if ((0, types_1.assertVariableStmt)(node)) {
                lintVariableStmt(file, node, false, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.ExpressionStatement:
            if ((0, types_1.assertExpressionStmt)(node)) {
                lintExpressionStmt(file, node, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.IfStatement:
            if ((0, types_1.assertIfStmt)(node)) {
                lintIfStmt(file, node, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.SwitchStatement:
            if ((0, types_1.assertSwitchStmt)(node)) {
                lintSwitchStmt(file, node, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.WhileStatement:
            if ((0, types_1.assertWhileStmt)(node)) {
                lintWhileStmt(file, node, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.ForStatement:
            if ((0, types_1.assertForStmt)(node)) {
                lintForStmt(file, node, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.ForOfStatement:
            if ((0, types_1.assertForOfStmt)(node)) {
                lintForOfStmt(file, node, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.ReturnStatement:
            if ((0, types_1.assertReturnStmt)(node)) {
                lintReturnStmt(file, node, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.ThrowStatement:
            if ((0, types_1.assertThrowStmt)(node)) {
                lintThrowStmt(file, node, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.TryStatement:
            if ((0, types_1.assertTryStmt)(node)) {
                lintTryStmt(file, node, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.DoStatement:
            if ((0, types_1.assertDoStmt)(node)) {
                file.error("do statements are not allowed", node.statement.pos - 2);
            }
            break;
        case typescript_1.SyntaxKind.ForInStatement:
            if ((0, types_1.assertForInStmt)(node)) {
                file.error("for-in statements are not allowed", node.expression.pos, node.expression.end);
            }
            break;
        case typescript_1.SyntaxKind.WithStatement:
            if ((0, types_1.assertWithStmt)(node)) {
                file.error("with statements are not allowed", node.expression.pos, node.expression.end);
            }
            break;
        case typescript_1.SyntaxKind.LabeledStatement:
            if ((0, types_1.assertLabeledStmt)(node)) {
                file.error("labeled statements are not allowed", node.label.end - 1);
            }
            break;
        case typescript_1.SyntaxKind.Block:
            if ((0, types_1.assertBlock)(node)) {
                lintBlock(file, node, false);
            }
            break;
        default:
            file.error("unexpected statement type: ".concat(typescript_1.SyntaxKind[node.kind]), node.pos + 1);
    }
};
// Lints the given if statement.
var lintIfStmt = function (file, node, isConstructor) {
    lintExpression(file, node.expression, isConstructor);
    lintStatement(file, node.thenStatement, isConstructor);
    if (node.elseStatement !== undefined) {
        lintStatement(file, node.elseStatement, isConstructor);
    }
};
// Lints the given switch statement.
var lintSwitchStmt = function (file, node, isConstructor) {
    var e_11, _a, e_12, _b;
    lintExpression(file, node.expression, isConstructor);
    try {
        for (var _c = __values(node.caseBlock.clauses), _d = _c.next(); !_d.done; _d = _c.next()) {
            var clause = _d.value;
            if (clause.kind === typescript_1.SyntaxKind.CaseClause) {
                lintExpression(file, clause.expression, isConstructor);
            }
            try {
                for (var _e = (e_12 = void 0, __values(clause.statements)), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var stmt = _f.value;
                    lintStatement(file, stmt, isConstructor);
                }
            }
            catch (e_12_1) { e_12 = { error: e_12_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_12) throw e_12.error; }
            }
        }
    }
    catch (e_11_1) { e_11 = { error: e_11_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_11) throw e_11.error; }
    }
};
var INV_RE = /^(\s+|\s*\/\/[^\n]*\n)*\/\/\s+Inv:\s+/;
// Lints the given while statement.
var lintWhileStmt = function (file, node, isConstructor) {
    if (file.reqInvariants) {
        var text = node.getFullText(file.root);
        if (text.match(INV_RE) === null) {
            var index = text.indexOf("while"); // not perfect, but better than nothing
            file.error("while loops must have an invariant", node.pos + index);
        }
    }
    lintExpression(file, node.expression, isConstructor);
    lintStatement(file, node.statement, isConstructor);
};
// Lints the given for statement.
var lintForStmt = function (file, node, isConstructor) {
    if (file.reqInvariants) {
        var text = node.getFullText(file.root);
        var index = text.indexOf("for"); // not perfect, but better than nothing
        file.error("for loops are not allowed (only while and for-each)", node.pos + index);
    }
    if (node.initializer !== undefined) {
        if (node.initializer.kind === typescript_1.SyntaxKind.VariableDeclarationList) {
            if ((0, types_1.assertVariableDeclList)(node.initializer)) {
                lintVariableDecl(file, node.initializer, false, true, isConstructor);
            }
        }
        else {
            lintExpression(file, node.initializer, isConstructor);
        }
    }
    if (node.condition !== undefined) {
        lintExpression(file, node.condition, isConstructor);
    }
    if (node.incrementor !== undefined) {
        // This is the one place that we allow ++ and --. Must be of an identifier
        if (isVariableIncDec(node.incrementor)) {
            // OK
        }
        else {
            lintExpression(file, node.incrementor, isConstructor);
        }
    }
    lintStatement(file, node.statement, isConstructor);
};
// Lints the given for-of statement.
var lintForOfStmt = function (file, node, isConstructor) {
    // NOTE: no invariant ever required
    if (node.initializer.kind === typescript_1.SyntaxKind.VariableDeclarationList) {
        if ((0, types_1.assertVariableDeclList)(node.initializer)) {
            lintVariableDecl(file, node.initializer, false, false, isConstructor);
        }
    }
    else {
        lintExpression(file, node.initializer, isConstructor);
    }
    lintExpression(file, node.expression, isConstructor);
    lintStatement(file, node.statement, isConstructor);
};
// Lints the given return statement.
var lintReturnStmt = function (file, node, isConstructor) {
    if (node.expression !== undefined) {
        lintExpression(file, node.expression, isConstructor);
    }
};
// Lints the given throw statement.
var lintThrowStmt = function (file, node, isConstructor) {
    if (node.expression !== undefined) {
        lintExpression(file, node.expression, isConstructor);
    }
};
// Lints the given try statement.
var lintTryStmt = function (file, node, isConstructor) {
    lintBlock(file, node.tryBlock, isConstructor);
    if (node.catchClause !== undefined) {
        var decl = node.catchClause.variableDeclaration;
        if (decl !== undefined) {
            if (decl.type === undefined) {
                file.error("exception declarations must have a type", decl.name.end - 1);
            }
            else {
                lintType(file, decl.type);
            }
        }
        lintBlock(file, node.catchClause.block, isConstructor);
    }
    if (node.finallyBlock !== undefined) {
        lintBlock(file, node.finallyBlock, isConstructor);
    }
};
// Performs linting of a type.
var lintType = function (file, node, topLevel) {
    var e_13, _a, e_14, _b, e_15, _c, e_16, _d, e_17, _e;
    switch (node.kind) {
        case typescript_1.SyntaxKind.NumberKeyword:
        case typescript_1.SyntaxKind.StringKeyword:
        case typescript_1.SyntaxKind.BooleanKeyword:
        case typescript_1.SyntaxKind.UndefinedKeyword:
        case typescript_1.SyntaxKind.NullKeyword:
        case typescript_1.SyntaxKind.VoidKeyword:
        case typescript_1.SyntaxKind.UnknownKeyword:
        case typescript_1.SyntaxKind.BigIntKeyword:
            // OK
            break;
        case typescript_1.SyntaxKind.LiteralType: // string or integer literal
            // OK
            break;
        case typescript_1.SyntaxKind.AnyKeyword:
            file.error("any type is not allowed", node.pos);
            break;
        case typescript_1.SyntaxKind.TypeReference: // use of a type alias
            if ((0, types_1.assertTypeReference)(node)) {
                if (node.typeArguments !== undefined) {
                    try {
                        for (var _f = __values(node.typeArguments), _g = _f.next(); !_g.done; _g = _f.next()) { // type arguments
                            var arg = _g.value;
                            lintType(file, arg);
                        }
                    }
                    catch (e_13_1) { e_13 = { error: e_13_1 }; }
                    finally {
                        try {
                            if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
                        }
                        finally { if (e_13) throw e_13.error; }
                    }
                }
            }
            break;
        case typescript_1.SyntaxKind.TypeOperator:
            if ((0, types_1.assertTypeOperator)(node)) {
                lintType(file, node.type);
            }
            break;
        case typescript_1.SyntaxKind.TupleType:
            if ((0, types_1.assertTupleType)(node)) {
                for (var i = 0; i < node.elements.length; i++) {
                    lintType(file, node.elements[i]);
                }
            }
            break;
        case typescript_1.SyntaxKind.UnionType:
            if ((0, types_1.assertUnionType)(node)) {
                try {
                    for (var _h = __values(node.types), _j = _h.next(); !_j.done; _j = _h.next()) {
                        var typ = _j.value;
                        lintType(file, typ);
                    }
                }
                catch (e_14_1) { e_14 = { error: e_14_1 }; }
                finally {
                    try {
                        if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
                    }
                    finally { if (e_14) throw e_14.error; }
                }
            }
            break;
        case typescript_1.SyntaxKind.ArrayType:
            if ((0, types_1.assertArrayType)(node)) {
                lintType(file, node.elementType);
            }
            break;
        case typescript_1.SyntaxKind.TypeLiteral: // record type
            if ((0, types_1.assertTypeLiteral)(node)) {
                try {
                    for (var _k = __values(node.members), _l = _k.next(); !_l.done; _l = _k.next()) {
                        var member = _l.value;
                        if (member.kind === typescript_1.SyntaxKind.PropertySignature) {
                            if ((0, types_1.assertPropertySignature)(member)) {
                                if (member.type === undefined) {
                                    file.error("fields of records must have a type", member.name.end - 1);
                                }
                                else {
                                    lintType(file, member.type);
                                }
                            }
                        }
                        else {
                            file.error("unexpected type literal member: ".concat(typescript_1.SyntaxKind[member.kind]), member.pos + 1);
                        }
                    }
                }
                catch (e_15_1) { e_15 = { error: e_15_1 }; }
                finally {
                    try {
                        if (_l && !_l.done && (_c = _k.return)) _c.call(_k);
                    }
                    finally { if (e_15) throw e_15.error; }
                }
            }
            break;
        case typescript_1.SyntaxKind.FunctionType:
            if ((0, types_1.assertFunctionType)(node)) {
                try {
                    for (var _m = __values(node.parameters), _o = _m.next(); !_o.done; _o = _m.next()) {
                        var param = _o.value;
                        if (param.type === undefined) {
                            file.error("parameters of functions must have a type", param.name.end - 1);
                        }
                        else {
                            lintType(file, param.type);
                        }
                    }
                }
                catch (e_16_1) { e_16 = { error: e_16_1 }; }
                finally {
                    try {
                        if (_o && !_o.done && (_d = _m.return)) _d.call(_m);
                    }
                    finally { if (e_16) throw e_16.error; }
                }
                lintType(file, node.type);
            }
            break;
        case typescript_1.SyntaxKind.TypePredicate:
            if ((0, types_1.assertTypePredicate)(node)) {
                if (node.type !== undefined) {
                    lintType(file, node.type);
                }
            }
            break;
        case typescript_1.SyntaxKind.IntersectionType:
            if ((0, types_1.assertIntersectionType)(node)) {
                if (!topLevel) {
                    file.error("intersection types are only allowed in top-level alias declarations", node.end - 1);
                }
                else {
                    try {
                        for (var _p = __values(node.types), _q = _p.next(); !_q.done; _q = _p.next()) {
                            var typ = _q.value;
                            lintType(file, typ);
                        }
                    }
                    catch (e_17_1) { e_17 = { error: e_17_1 }; }
                    finally {
                        try {
                            if (_q && !_q.done && (_e = _p.return)) _e.call(_p);
                        }
                        finally { if (e_17) throw e_17.error; }
                    }
                }
            }
            break;
        default:
            file.error("unexpected type: ".concat(typescript_1.SyntaxKind[node.kind]), node.pos + 1);
            break;
    }
};
// Performs linting of an expression statement.
var lintExpressionStmt = function (file, node, isConstructor) {
    lintExpression(file, node.expression, isConstructor);
};
// Performs linting of an expression.
var lintExpression = function (file, node, isConstructor) {
    var e_18, _a, e_19, _b, e_20, _c, e_21, _d, e_22, _e;
    switch (node.kind) {
        case typescript_1.SyntaxKind.Identifier:
        case typescript_1.SyntaxKind.NumericLiteral:
        case typescript_1.SyntaxKind.StringLiteral:
        case typescript_1.SyntaxKind.TrueKeyword:
        case typescript_1.SyntaxKind.FalseKeyword:
        case typescript_1.SyntaxKind.NullKeyword:
        case typescript_1.SyntaxKind.ThisKeyword:
        case typescript_1.SyntaxKind.SuperKeyword:
        case typescript_1.SyntaxKind.BigIntLiteral:
            // OK
            break;
        case typescript_1.SyntaxKind.ParenthesizedExpression:
            if ((0, types_1.assertParenthesizedExpr)(node)) {
                lintExpression(file, node.expression, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.PrefixUnaryExpression:
            if ((0, types_1.assertPrefixUnaryExpr)(node)) {
                if (node.operator === typescript_1.SyntaxKind.PlusPlusToken || node.operator === typescript_1.SyntaxKind.MinusMinusToken) {
                    file.error("++ and -- are not allowed", node.operand.pos - 2);
                }
                lintExpression(file, node.operand, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.PostfixUnaryExpression:
            if ((0, types_1.assertPostfixUnaryExpr)(node)) {
                file.error("++ and -- are not allowed", node.operand.end + 2);
            }
            break;
        case typescript_1.SyntaxKind.BinaryExpression:
            if ((0, types_1.assertBinaryExpr)(node)) {
                lintBinaryExpr(file, node, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.ConditionalExpression:
            if ((0, types_1.assertConditionalExpr)(node)) {
                lintExpression(file, node.condition, isConstructor);
                lintExpression(file, node.whenTrue, isConstructor);
                lintExpression(file, node.whenFalse, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.TypeOfExpression:
            if ((0, types_1.assertTypeOfExpr)(node)) {
                lintExpression(file, node.expression, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.PropertyAccessExpression:
            if ((0, types_1.assertPropertyAccessExpr)(node)) {
                lintExpression(file, node.expression, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.ElementAccessExpression:
            if ((0, types_1.assertElementAccessExpr)(node)) {
                lintExpression(file, node.argumentExpression, isConstructor);
                lintExpression(file, node.expression, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.NewExpression:
            if ((0, types_1.assertNewExpr)(node)) {
                if (node.expression.kind !== typescript_1.SyntaxKind.Identifier) {
                    file.error("expecting an identifier after 'new'", node.expression.pos + 1);
                }
                if (node.typeArguments !== undefined) {
                    try {
                        for (var _f = __values(node.typeArguments), _g = _f.next(); !_g.done; _g = _f.next()) {
                            var arg = _g.value;
                            lintType(file, arg);
                        }
                    }
                    catch (e_18_1) { e_18 = { error: e_18_1 }; }
                    finally {
                        try {
                            if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
                        }
                        finally { if (e_18) throw e_18.error; }
                    }
                }
                if (node.arguments !== undefined) {
                    try {
                        for (var _h = __values(node.arguments), _j = _h.next(); !_j.done; _j = _h.next()) {
                            var arg = _j.value;
                            lintExpression(file, arg, isConstructor);
                        }
                    }
                    catch (e_19_1) { e_19 = { error: e_19_1 }; }
                    finally {
                        try {
                            if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
                        }
                        finally { if (e_19) throw e_19.error; }
                    }
                }
            }
            break;
        case typescript_1.SyntaxKind.CallExpression:
            if ((0, types_1.assertCallExpr)(node)) {
                lintCallExpr(file, node, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.TemplateExpression:
            if ((0, types_1.assertTemplateExpr)(node)) {
                try {
                    for (var _k = __values(node.templateSpans), _l = _k.next(); !_l.done; _l = _k.next()) {
                        var span = _l.value;
                        lintExpression(file, span.expression, isConstructor);
                    }
                }
                catch (e_20_1) { e_20 = { error: e_20_1 }; }
                finally {
                    try {
                        if (_l && !_l.done && (_c = _k.return)) _c.call(_k);
                    }
                    finally { if (e_20) throw e_20.error; }
                }
            }
            break;
        case typescript_1.SyntaxKind.ArrayLiteralExpression:
            if ((0, types_1.assertArrayLiteralExpr)(node)) {
                try {
                    for (var _m = __values(node.elements), _o = _m.next(); !_o.done; _o = _m.next()) {
                        var elem = _o.value;
                        lintExpression(file, elem, isConstructor);
                    }
                }
                catch (e_21_1) { e_21 = { error: e_21_1 }; }
                finally {
                    try {
                        if (_o && !_o.done && (_d = _m.return)) _d.call(_m);
                    }
                    finally { if (e_21) throw e_21.error; }
                }
            }
            break;
        case typescript_1.SyntaxKind.ObjectLiteralExpression:
            if ((0, types_1.assertObjectLiteralExpr)(node)) {
                try {
                    for (var _p = __values(node.properties), _q = _p.next(); !_q.done; _q = _p.next()) {
                        var elem = _q.value;
                        lintObjectLiteralProperty(file, elem, isConstructor);
                    }
                }
                catch (e_22_1) { e_22 = { error: e_22_1 }; }
                finally {
                    try {
                        if (_q && !_q.done && (_e = _p.return)) _e.call(_p);
                    }
                    finally { if (e_22) throw e_22.error; }
                }
            }
            break;
        case typescript_1.SyntaxKind.SpreadElement:
            file.error("spread expressions are not allowed", node.pos + 1);
            break;
        case typescript_1.SyntaxKind.JsxElement:
            if ((0, types_1.assertJsxElem)(node)) {
                lintJsxElem(file, node, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.JsxSelfClosingElement:
            if ((0, types_1.assertJsxSelfClosingElem)(node)) {
                lintJsxSelfClosingElem(file, node, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.JsxFragment:
            if ((0, types_1.assertJsxFragment)(node)) {
                lintJsxFragment(file, node, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.ArrowFunction:
            if ((0, types_1.assertArrowFunction)(node)) {
                if (node.body.kind === typescript_1.SyntaxKind.Block && (0, types_1.assertBlock)(node.body)) {
                    file.error("only simple function expressions are allowed (not blocks)", node.parameters.pos, node.body.end);
                }
                else {
                    var text = node.getFullText(file.root).trim();
                    if (text.indexOf("\n") !== -1 || text.length > 100) {
                        file.error("only simple function expressions are allowed", node.parameters.pos, node.body.end);
                    }
                    else {
                        lintExpression(file, node.body, isConstructor);
                    }
                }
            }
            break;
        case typescript_1.SyntaxKind.FunctionExpression:
            if (!isTestFile(file)) {
                file.error("function expressions are not allowed here", node.pos, node.end);
            }
            else {
                if ((0, types_1.assertFunctionExpression)(node)) {
                    lintBlock(file, node.body, isConstructor);
                }
            }
            break;
        case typescript_1.SyntaxKind.NonNullExpression:
            if ((0, types_1.assertNonNullExpr)(node)) {
                file.error("non-null assertions are not allowed", node.end);
            }
            break;
        case typescript_1.SyntaxKind.ClassExpression:
            file.error("class expressions are not allowed", node.pos + 1);
            break;
        case typescript_1.SyntaxKind.AsExpression:
            file.error("type casts are not allowed", node.pos, node.end);
            break;
        case typescript_1.SyntaxKind.DeleteExpression:
            file.error("delete operator is not allowed", node.pos, node.end);
            break;
        case typescript_1.SyntaxKind.VoidExpression:
            file.error("void expression is not allowed", node.pos, node.end);
            break;
        case typescript_1.SyntaxKind.AwaitExpression:
            file.error("await expression is not allowed", node.pos, node.end);
            break;
        case typescript_1.SyntaxKind.YieldExpression:
            file.error("yield expression is not allowed", node.pos, node.end);
            break;
        case typescript_1.SyntaxKind.FirstTemplateToken:
            file.error("not a template string literal", node.pos, node.end);
            break;
        default:
            file.error("unexpected expression type: ".concat(typescript_1.SyntaxKind[node.kind]), node.pos, node.end);
            break;
    }
};
// Operators that perform assignments
var assignmentOperators = new Set([
    typescript_1.SyntaxKind.EqualsToken, typescript_1.SyntaxKind.PlusEqualsToken,
    typescript_1.SyntaxKind.MinusEqualsToken, typescript_1.SyntaxKind.AsteriskEqualsToken,
    typescript_1.SyntaxKind.AsteriskAsteriskEqualsToken, typescript_1.SyntaxKind.SlashEqualsToken,
    typescript_1.SyntaxKind.PercentEqualsToken, typescript_1.SyntaxKind.LessThanLessThanEqualsToken,
    typescript_1.SyntaxKind.GreaterThanGreaterThanEqualsToken,
    typescript_1.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken,
    typescript_1.SyntaxKind.AmpersandEqualsToken, typescript_1.SyntaxKind.BarEqualsToken,
    typescript_1.SyntaxKind.BarBarEqualsToken, typescript_1.SyntaxKind.AmpersandAmpersandEqualsToken,
    typescript_1.SyntaxKind.QuestionQuestionEqualsToken, typescript_1.SyntaxKind.CaretEqualsToken
]);
// Operators that perform boolean operations.
var booleanOperators = new Set([
    typescript_1.SyntaxKind.AmpersandAmpersandToken, typescript_1.SyntaxKind.BarBarToken
]);
// Operators that could be the root of a JSX subexpression.
var jsxOperators = new Set([
    typescript_1.SyntaxKind.JsxElement, typescript_1.SyntaxKind.JsxSelfClosingElement,
    typescript_1.SyntaxKind.JsxFragment
]);
// Perform linting of a binary expression.
var lintBinaryExpr = function (file, node, isConstructor) {
    lintExpression(file, node.left, isConstructor);
    lintExpression(file, node.right, isConstructor);
    if (booleanOperators.has(node.operatorToken.kind)) {
        if (jsxOperators.has(node.left.kind) || jsxOperators.has(node.right.kind)) {
            file.error("logical operators are not allowed on JSX elements", node.left.end, node.operatorToken.end);
        }
    }
    if (assignmentOperators.has(node.operatorToken.kind)) {
        if (file.allowMutation) {
            // okay
        }
        else if (isConstructor &&
            node.left.kind === typescript_1.SyntaxKind.PropertyAccessExpression &&
            (0, types_1.assertPropertyAccessExpr)(node.left) &&
            node.left.expression.kind === typescript_1.SyntaxKind.ThisKeyword) {
            // okay
        }
        else {
            file.error("mutation is not allowed", node.left.end, node.right.pos);
        }
    }
};
// Perform linting of a call expression.
var lintCallExpr = function (file, node, isConstructor) {
    var e_23, _a, e_24, _b;
    lintExpression(file, node.expression, isConstructor);
    if (node.typeArguments !== undefined) {
        try {
            for (var _c = __values(node.typeArguments), _d = _c.next(); !_d.done; _d = _c.next()) {
                var arg = _d.value;
                lintType(file, arg);
            }
        }
        catch (e_23_1) { e_23 = { error: e_23_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_23) throw e_23.error; }
        }
    }
    if (node.expression.kind === typescript_1.SyntaxKind.Identifier &&
        (0, types_1.assertIdentifier)(node.expression)) {
        var funcName = node.expression.text;
        if (funcName === "fetch") {
            lintFetch(file, node);
        }
    }
    // Changing conventions to use .json and .send
    //  } else if (node.expression.kind === SyntaxKind.PropertyAccessExpression &&
    //             assertPropertyAccessExpr(node.expression) &&
    //             node.expression.name.kind === SyntaxKind.Identifier &&
    //             assertIdentifier(node.expression.name)) {
    //    const methodName = node.expression.name.text;
    //    if ((methodName === "json" || methodName === "text") &&
    //        node.arguments.length === 1) {
    //      file.error(`call to .${methodName} is not allowed`, node.expression.name.end - 1);
    //    }
    //  }
    if (node.arguments !== undefined) {
        try {
            for (var _e = __values(node.arguments), _f = _e.next(); !_f.done; _f = _e.next()) {
                var arg = _f.value;
                lintExpression(file, arg, isConstructor);
            }
        }
        catch (e_24_1) { e_24 = { error: e_24_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            }
            finally { if (e_24) throw e_24.error; }
        }
    }
};
// Performs linting of a property within an object literal expression.
var lintObjectLiteralProperty = function (file, elem, isConstructor) {
    switch (elem.kind) {
        case typescript_1.SyntaxKind.PropertyAssignment:
            if ((0, types_1.assertPropertyAssignment)(elem)) {
                lintExpression(file, elem.initializer, isConstructor);
            }
            break;
        case typescript_1.SyntaxKind.ShorthandPropertyAssignment:
            // OK
            break;
        case typescript_1.SyntaxKind.SpreadAssignment:
            file.error("spread expressions are not allowed", elem.pos, elem.end);
            break;
        case typescript_1.SyntaxKind.MethodDeclaration:
            file.error("method declarations are not allowed", elem.pos, elem.end);
            break;
        default:
            file.error("unexpected property type: ".concat(typescript_1.SyntaxKind[elem.kind]), elem.pos, elem.end);
            break;
    }
};
// Performs linting of a JSX element.
var lintJsxElem = function (file, node, isConstructor) {
    var e_25, _a;
    lintJsxAttributes(file, node.openingElement.attributes, isConstructor);
    try {
        for (var _b = __values(node.children), _c = _b.next(); !_c.done; _c = _b.next()) {
            var child = _c.value;
            lintJsxChild(file, child, isConstructor);
        }
    }
    catch (e_25_1) { e_25 = { error: e_25_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_25) throw e_25.error; }
    }
};
// Performs linting of a JSX self-closing element.
var lintJsxSelfClosingElem = function (file, node, isConstructor) {
    lintJsxAttributes(file, node.attributes, isConstructor);
};
// Performs linting of a JSX element.
var lintJsxAttributes = function (file, attributes, isConstructor) {
    var e_26, _a;
    try {
        for (var _b = __values(attributes.properties), _c = _b.next(); !_c.done; _c = _b.next()) {
            var attr = _c.value;
            if (attr.kind !== typescript_1.SyntaxKind.JsxAttribute) {
                file.error("spread attributes are not allowed", attr.pos, attr.end);
            }
            else if ((0, types_1.assertJsxAttribute)(attr)) {
                if (attr.initializer !== undefined) {
                    if (attr.initializer.kind === typescript_1.SyntaxKind.StringLiteral) {
                        // OK
                    }
                    else if (attr.initializer.kind === typescript_1.SyntaxKind.JsxExpression &&
                        (0, types_1.assertJsxExpr)(attr.initializer)) {
                        var expr = attr.initializer.expression;
                        if (expr !== undefined) {
                            lintExpression(file, expr, isConstructor);
                        }
                    }
                    else {
                        file.error("unexpected attribute type: ".concat(typescript_1.SyntaxKind[attr.initializer.kind]), attr.pos, attr.end);
                    }
                }
            }
        }
    }
    catch (e_26_1) { e_26 = { error: e_26_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_26) throw e_26.error; }
    }
};
// Performs linting of a JSX fragment.
var lintJsxFragment = function (file, node, isConstructor) {
    var e_27, _a;
    try {
        for (var _b = __values(node.children), _c = _b.next(); !_c.done; _c = _b.next()) {
            var child = _c.value;
            lintJsxChild(file, child, isConstructor);
        }
    }
    catch (e_27_1) { e_27 = { error: e_27_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_27) throw e_27.error; }
    }
};
// Performs linting of a JSX child.
var lintJsxChild = function (file, child, isConstructor) {
    switch (child.kind) {
        case typescript_1.SyntaxKind.JsxText:
            // OK
            break;
        case typescript_1.SyntaxKind.JsxExpression:
            if ((0, types_1.assertJsxExpr)(child)) {
                if (child.expression !== undefined) {
                    lintExpression(file, child.expression, isConstructor);
                }
            }
            break;
        case typescript_1.SyntaxKind.JsxElement:
            lintJsxElem(file, child, isConstructor);
            break;
        case typescript_1.SyntaxKind.JsxSelfClosingElement:
            lintJsxSelfClosingElem(file, child, isConstructor);
            break;
        case typescript_1.SyntaxKind.JsxFragment:
            lintJsxFragment(file, child, isConstructor);
            break;
        default:
            throw new Error("impossible");
    }
};
// Performs linting of a call to fetch.
var lintFetch = function (file, node) {
    if (node.arguments.length === 1) {
        // OK
    }
    else if (node.arguments.length === 2) {
        var arg = node.arguments[1];
        if (arg.kind !== typescript_1.SyntaxKind.ObjectLiteralExpression) {
            file.error("second argument to fetch should be a record", arg.pos, arg.end);
        }
        else if ((0, types_1.assertObjectLiteralExpr)(arg)) {
            var fields = getFields(arg);
            var method = fields.get("method");
            if (method === undefined) {
                file.error("missing 'method' field in the call to fetch", arg.pos, arg.end);
            }
            else if (method.kind !== typescript_1.SyntaxKind.StringLiteral ||
                (0, types_1.assertStringLiteral)(method) && (method.text !== "POST")) {
                file.error("'method' is only required for POST requests", method.pos, method.end);
            }
            var body = fields.get("body");
            if (body === undefined) {
                file.error("missing 'body' field in the call to fetch", arg.pos, arg.end);
            }
            var headers = fields.get("headers");
            if (headers === undefined) {
                file.error("missing 'headers' field in the call to fetch", arg.pos, arg.end);
            }
            else if (headers.kind === typescript_1.SyntaxKind.ObjectLiteralExpression &&
                (0, types_1.assertObjectLiteralExpr)(headers)) {
                var headerFields = getFields(headers);
                var contentType = headerFields.get("Content-Type");
                if (contentType === undefined) {
                    file.error("missing 'Content-Type' header in the call to fetch", arg.pos, arg.end);
                }
                else if (contentType.kind !== typescript_1.SyntaxKind.StringLiteral ||
                    (0, types_1.assertStringLiteral)(contentType) && (contentType.text !== "application/json")) {
                    file.error("'Content-Type' header should be 'application/json'", arg.pos, arg.end);
                }
            }
            else {
                file.error("'headers' should be an object literal", arg.pos, arg.end);
            }
        }
    }
    else {
        file.error("expecting one or two arguments to fetch", node.arguments.pos, node.arguments.end);
    }
};
// Returns a map from constant field names to their value expressions in an
// object literal expression (non-constant fields are ignored).
var getFields = function (expr) {
    var e_28, _a;
    var fields = new Map();
    try {
        for (var _b = __values(expr.properties), _c = _b.next(); !_c.done; _c = _b.next()) {
            var prop = _c.value;
            if (prop.kind === typescript_1.SyntaxKind.PropertyAssignment &&
                (0, types_1.assertPropertyAssignment)(prop)) {
                var name_2 = getName(prop.name);
                if (name_2 !== undefined) {
                    fields.set(name_2, prop.initializer);
                }
            }
        }
    }
    catch (e_28_1) { e_28 = { error: e_28_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_28) throw e_28.error; }
    }
    return fields;
};
// Returns the name of a property or undefined if not unedrstood.
var getName = function (name) {
    if (name.kind === typescript_1.SyntaxKind.Identifier && (0, types_1.assertIdentifier)(name)) {
        return name.text;
    }
    else if (name.kind === typescript_1.SyntaxKind.StringLiteral && (0, types_1.assertStringLiteral)(name)) {
        return name.text;
    }
    else {
        return undefined;
    }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGludGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2xpbnRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBLHlDQVMrRTtBQUMvRSxpQ0FrQndGO0FBc0J4RixxQ0FBcUM7QUFDckMsSUFBTSxVQUFVLEdBQUcsVUFBQyxJQUFZO0lBQzlCLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDO1FBQ2xDLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQzdDLENBQUMsQ0FBQztBQUdGLDhEQUE4RDtBQUM5RCxJQUFNLGdCQUFnQixHQUFHLFVBQUMsSUFBZ0I7SUFDeEMsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLHVCQUFVLENBQUMscUJBQXFCLEVBQUU7UUFDbEQsSUFBSSxJQUFBLDZCQUFxQixFQUFDLElBQUksQ0FBQyxFQUFFO1lBQy9CLE9BQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxLQUFLLHVCQUFVLENBQUMsYUFBYTtnQkFDMUMsSUFBSSxDQUFDLFFBQVEsS0FBSyx1QkFBVSxDQUFDLGVBQWUsQ0FBQztnQkFDOUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEtBQUssdUJBQVUsQ0FBQyxVQUFVLENBQUM7U0FDcEQ7S0FDRjtTQUFNLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyx1QkFBVSxDQUFDLHNCQUFzQixFQUFFO1FBQzFELElBQUksSUFBQSw4QkFBc0IsRUFBQyxJQUFJLENBQUMsRUFBRTtZQUNoQyxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsS0FBSyx1QkFBVSxDQUFDLGFBQWE7Z0JBQzFDLElBQUksQ0FBQyxRQUFRLEtBQUssdUJBQVUsQ0FBQyxlQUFlLENBQUM7Z0JBQzlDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxLQUFLLHVCQUFVLENBQUMsVUFBVSxDQUFDO1NBQ3BEO0tBQ0Y7SUFDRCxPQUFPLEtBQUssQ0FB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