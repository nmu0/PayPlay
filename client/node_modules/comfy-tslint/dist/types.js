"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertJsxElem = exports.assertNonNullExpr = exports.assertPropertyAssignment = exports.assertObjectLiteralExpr = exports.assertArrayLiteralExpr = exports.assertTemplateExpr = exports.assertNewExpr = exports.assertCallExpr = exports.assertElementAccessExpr = exports.assertPropertyAccessExpr = exports.assertSpreadElement = exports.assertTypeOfExpr = exports.assertConditionalExpr = exports.assertBinaryExpr = exports.assertPostfixUnaryExpr = exports.assertPrefixUnaryExpr = exports.assertParenthesizedExpr = exports.assertTryStmt = exports.assertThrowStmt = exports.assertReturnStmt = exports.assertLabeledStmt = exports.assertWithStmt = exports.assertWhileStmt = exports.assertForOfStmt = exports.assertForInStmt = exports.assertForStmt = exports.assertDoStmt = exports.assertSwitchStmt = exports.assertExpressionStmt = exports.assertIfStmt = exports.assertVariableStmt = exports.assertVariableDeclList = exports.assertFunctionDecl = exports.assertStringLiteral = exports.assertIdentifier = exports.assertBlock = exports.assertFunctionExpression = exports.assertArrowFunction = exports.assertIntersectionType = exports.assertTypePredicate = exports.assertPropertySignature = exports.assertTypeLiteral = exports.assertFunctionType = exports.assertUnionType = exports.assertTupleType = exports.assertArrayType = exports.assertTypeReference = exports.assertTypeOperator = exports.assertTypeAliasDecl = exports.assertImportDecl = void 0;
exports.hasJSDoc = exports.isRecord = exports.assertMethodDecl = exports.assertMethodSignature = exports.assertConstructorDecl = exports.assertPropertyDecl = exports.assertClassDecl = exports.assertInterfaceDecl = exports.assertExpressionWithTypeArguments = exports.assertBindingElement = exports.assertArrayBindingPattern = exports.assertJsxAttribute = exports.assertJsxExpr = exports.assertJsxFragment = exports.assertJsxSelfClosingElem = void 0;
var typescript_1 = require("typescript");
/**
 * Ensures the given node is an ImportDeclaration.
 * @param node Node to check
 * @throws Error if it is not an import
 */
var assertImportDecl = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.ImportDeclaration) {
        throw new Error("Expected ImportDeclaration, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertImportDecl = assertImportDecl;
/**
 * Ensures the given node is an TypeAliasDeclaration.
 * @param node Node to check
 * @throws Error if it is not a type alias
 */
var assertTypeAliasDecl = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.TypeAliasDeclaration) {
        throw new Error("Expected TypeAliasDeclaration, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertTypeAliasDecl = assertTypeAliasDecl;
/**
 * Ensures the given node is an TypeOperatorNode.
 * @param node Node to check
 * @throws Error if it is not a type operator
 */
var assertTypeOperator = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.TypeOperator) {
        throw new Error("Expected TypeOperatorNode, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertTypeOperator = assertTypeOperator;
/**
 * Ensures the given node is a TypeReference.
 * @param node Node to check
 * @throws Error if it is not a type reference
 */
var assertTypeReference = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.TypeReference) {
        throw new Error("Expected TypeReference, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertTypeReference = assertTypeReference;
/**
 * Ensures the given node is an ArrayType.
 * @param node Node to check
 * @throws Error if it is not an array type
 */
var assertArrayType = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.ArrayType) {
        throw new Error("Expected ArrayType, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertArrayType = assertArrayType;
/**
 * Ensures the given node is a TupleType.
 * @param node Node to check
 * @throws Error if it is not a tuple type
 */
var assertTupleType = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.TupleType) {
        throw new Error("Expected TupleType, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertTupleType = assertTupleType;
/**
 * Ensures the given node is a UnionType.
 * @param node Node to check
 * @throws Error if it is not a union type
 */
var assertUnionType = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.UnionType) {
        throw new Error("Expected UnionType, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertUnionType = assertUnionType;
/**
 * Ensures the given node is an FunctionType.
 * @param node Node to check
 * @throws Error if it is not a function type
 */
var assertFunctionType = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.FunctionType) {
        throw new Error("Expected FunctionType, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertFunctionType = assertFunctionType;
/**
 * Ensures the given node is a TypeLiteral.
 * @param node Node to check
 * @throws Error if it is not a type literal (record type)
 */
var assertTypeLiteral = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.TypeLiteral) {
        throw new Error("Expected TypeLiteral, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertTypeLiteral = assertTypeLiteral;
/**
 * Ensures the given node is a PropertySignature.
 * @param node Node to check
 * @throws Error if it is not a property signature
 */
var assertPropertySignature = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.PropertySignature) {
        throw new Error("Expected PropertySignature, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertPropertySignature = assertPropertySignature;
/**
 * Ensures the given node is a TypePredicate.
 * @param node Node to check
 * @throws Error if it is not a type literal (record type)
 */
var assertTypePredicate = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.TypePredicate) {
        throw new Error("Expected TypePredicate, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertTypePredicate = assertTypePredicate;
/**
 * Ensures the given node is a TypeIntersection.
 * @param node Node to check
 * @throws Error if it is not a type literal (record type)
 */
var assertIntersectionType = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.IntersectionType) {
        throw new Error("Expected IntersectionType, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertIntersectionType = assertIntersectionType;
/**
 * Ensures the given node is an ArrowFunction.
 * @param node Node to check
 * @throws Error if it is not an arrow function
 */
var assertArrowFunction = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.ArrowFunction) {
        throw new Error("Expected ArrowFunction, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertArrowFunction = assertArrowFunction;
/**
 * Ensures the given node is a FunctionExpression.
 * @param node Node to check
 * @throws Error if it is not a function expression
 */
var assertFunctionExpression = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.FunctionExpression) {
        throw new Error("Expected FunctionExpression, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertFunctionExpression = assertFunctionExpression;
/**
 * Ensures the given node is a block.
 * @param node Node to check
 * @throws Error if it is not a block
 */
var assertBlock = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.Block) {
        throw new Error("Expected Block, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertBlock = assertBlock;
/**
 * Ensures the given node is an Identifier.
 * @param node Node to check
 * @throws Error if it is not an identifier
 */
var assertIdentifier = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.Identifier) {
        throw new Error("Expected Identifier, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertIdentifier = assertIdentifier;
/**
 * Ensures the given node is a StringLiteral.
 * @param node Node to check
 * @throws Error if it is not a string literal
 */
var assertStringLiteral = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.StringLiteral) {
        throw new Error("Expected StringLiteral, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertStringLiteral = assertStringLiteral;
/**
 * Ensures the given node is a FunctionDeclaration.
 * @param node Node to check
 * @throws Error if it is not a function declaration
 */
var assertFunctionDecl = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.FunctionDeclaration) {
        throw new Error("Expected FunctionDeclaration, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertFunctionDecl = assertFunctionDecl;
/**
 * Ensures the given node is an VariableDeclarationList.
 * @param node Node to check
 * @throws Error if it is not a variable declaration list
 */
var assertVariableDeclList = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.VariableDeclarationList) {
        throw new Error("Expected VariableDeclarationList, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertVariableDeclList = assertVariableDeclList;
/**
 * Ensures the given node is an VariableStatement.
 * @param node Node to check
 * @throws Error if it is not a variable statement
 */
var assertVariableStmt = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.VariableStatement) {
        throw new Error("Expected VariableStatement, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertVariableStmt = assertVariableStmt;
/**
 * Ensures the given node is an IfStatement.
 * @param node Node to check
 * @throws Error if it is not an if statement
 */
var assertIfStmt = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.IfStatement) {
        throw new Error("Expected IfStatement, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertIfStmt = assertIfStmt;
/**
 * Ensures the given node is an ExpressionStatement.
 * @param node Node to check
 * @throws Error if it is not an expression statement
 */
var assertExpressionStmt = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.ExpressionStatement) {
        throw new Error("Expected ExpressionStatement, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertExpressionStmt = assertExpressionStmt;
/**
 * Ensures the given node is an SwitchStatement.
 * @param node Node to check
 * @throws Error if it is not a switch statement
 */
var assertSwitchStmt = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.SwitchStatement) {
        throw new Error("Expected SwitchStatement, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertSwitchStmt = assertSwitchStmt;
/**
 * Ensures the given node is an DoStatement.
 * @param node Node to check
 * @throws Error if it is not a do statement
 */
var assertDoStmt = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.DoStatement) {
        throw new Error("Expected DoStatement, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertDoStmt = assertDoStmt;
/**
 * Ensures the given node is an ForStatement.
 * @param node Node to check
 * @throws Error if it is not a for statement
 */
var assertForStmt = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.ForStatement) {
        throw new Error("Expected ForStatement, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertForStmt = assertForStmt;
/**
 * Ensures the given node is an ForInStatement.
 * @param node Node to check
 * @throws Error if it is not a for-in statement
 */
var assertForInStmt = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.ForInStatement) {
        throw new Error("Expected ForInStatement, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertForInStmt = assertForInStmt;
/**
 * Ensures the given node is an ForOfStatement.
 * @param node Node to check
 * @throws Error if it is not a for-of statement
 */
var assertForOfStmt = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.ForOfStatement) {
        throw new Error("Expected ForOfStatement, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertForOfStmt = assertForOfStmt;
/**
 * Ensures the given node is an WhileStatement.
 * @param node Node to check
 * @throws Error if it is not a while statement
 */
var assertWhileStmt = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.WhileStatement) {
        throw new Error("Expected WhileStatement, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertWhileStmt = assertWhileStmt;
/**
 * Ensures the given node is an WithStatement.
 * @param node Node to check
 * @throws Error if it is not a with statement
 */
var assertWithStmt = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.WithStatement) {
        throw new Error("Expected WithStatement, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertWithStmt = assertWithStmt;
/**
 * Ensures the given node is an LabeledStatement.
 * @param node Node to check
 * @throws Error if it is not a labeled statement
 */
var assertLabeledStmt = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.LabeledStatement) {
        throw new Error("Expected LabeledStatement, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertLabeledStmt = assertLabeledStmt;
/**
 * Ensures the given node is an ReturnStatement.
 * @param node Node to check
 * @throws Error if it is not a return statement
 */
var assertReturnStmt = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.ReturnStatement) {
        throw new Error("Expected ReturnStatement, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertReturnStmt = assertReturnStmt;
/**
 * Ensures the given node is an ThrowStatement.
 * @param node Node to check
 * @throws Error if it is not a throw statement
 */
var assertThrowStmt = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.ThrowStatement) {
        throw new Error("Expected ThrowStatement, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertThrowStmt = assertThrowStmt;
/**
 * Ensures the given node is an TryStatement.
 * @param node Node to check
 * @throws Error if it is not a try statement
 */
var assertTryStmt = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.TryStatement) {
        throw new Error("Expected TryStatement, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertTryStmt = assertTryStmt;
/**
 * Ensures the given node is an ParenthesizedExpression.
 * @param node Node to check
 * @throws Error if it is not a parenthesized expression
 */
var assertParenthesizedExpr = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.ParenthesizedExpression) {
        throw new Error("Expected ParenthesizedExpression, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertParenthesizedExpr = assertParenthesizedExpr;
/**
 * Ensures the given node is an PrefixUnaryExpression.
 * @param node Node to check
 * @throws Error if it is not a (prefix) unary expression
 */
var assertPrefixUnaryExpr = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.PrefixUnaryExpression) {
        throw new Error("Expected PrefixUnaryExpression, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertPrefixUnaryExpr = assertPrefixUnaryExpr;
/**
 * Ensures the given node is an PostfixUnaryExpression.
 * @param node Node to check
 * @throws Error if it is not a (postfix) unary expression
 */
var assertPostfixUnaryExpr = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.PostfixUnaryExpression) {
        throw new Error("Expected PostfixUnaryExpression, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertPostfixUnaryExpr = assertPostfixUnaryExpr;
/**
 * Ensures the given node is an BinaryExpression.
 * @param node Node to check
 * @throws Error if it is not a binary expression
 */
var assertBinaryExpr = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.BinaryExpression) {
        throw new Error("Expected BinaryExpression, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertBinaryExpr = assertBinaryExpr;
/**
 * Ensures the given node is an ConditionalExpression.
 * @param node Node to check
 * @throws Error if it is not a conditional expression
 */
var assertConditionalExpr = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.ConditionalExpression) {
        throw new Error("Expected ConditionalExpression, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertConditionalExpr = assertConditionalExpr;
/**
 * Ensures the given node is an TypeOfExpression.
 * @param node Node to check
 * @throws Error if it is not a type-of expression
 */
var assertTypeOfExpr = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.TypeOfExpression) {
        throw new Error("Expected TypeOfExpression, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertTypeOfExpr = assertTypeOfExpr;
/**
 * Ensures the given node is an SpreadElement.
 * @param node Node to check
 * @throws Error if it is not a spread element
 */
var assertSpreadElement = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.SpreadElement) {
        throw new Error("Expected SpreadElement, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertSpreadElement = assertSpreadElement;
/**
 * Ensures the given node is an PropertyAccessExpression.
 * @param node Node to check
 * @throws Error if it is not a property access expression
 */
var assertPropertyAccessExpr = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.PropertyAccessExpression) {
        throw new Error("Expected PropertyAccessExpression, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertPropertyAccessExpr = assertPropertyAccessExpr;
/**
 * Ensures the given node is an ElementAccessExpression.
 * @param node Node to check
 * @throws Error if it is not a element access expression
 */
var assertElementAccessExpr = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.ElementAccessExpression) {
        throw new Error("Expected ElementAccessExpression, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertElementAccessExpr = assertElementAccessExpr;
/**
 * Ensures the given node is an CallExpression.
 * @param node Node to check
 * @throws Error if it is not a call expression
 */
var assertCallExpr = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.CallExpression) {
        throw new Error("Expected CallExpression, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertCallExpr = assertCallExpr;
/**
 * Ensures the given node is an NewExpression.
 * @param node Node to check
 * @throws Error if it is not a new expression
 */
var assertNewExpr = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.NewExpression) {
        throw new Error("Expected NewExpression, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertNewExpr = assertNewExpr;
/**
 * Ensures the given node is an TemplateExpression.
 * @param node Node to check
 * @throws Error if it is not a template literal expression
 */
var assertTemplateExpr = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.TemplateExpression) {
        throw new Error("Expected TemplateExpression, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertTemplateExpr = assertTemplateExpr;
/**
 * Ensures the given node is an ArrayLiteralExpression.
 * @param node Node to check
 * @throws Error if it is not an array literal expression
 */
var assertArrayLiteralExpr = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.ArrayLiteralExpression) {
        throw new Error("Expected ArrayLiteralExpression, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertArrayLiteralExpr = assertArrayLiteralExpr;
/**
 * Ensures the given node is an ObjectLiteralExpression.
 * @param node Node to check
 * @throws Error if it is not an object literal expression
 */
var assertObjectLiteralExpr = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.ObjectLiteralExpression) {
        throw new Error("Expected ObjectLiteralExpression, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertObjectLiteralExpr = assertObjectLiteralExpr;
/**
 * Ensures the given node is an PropertyAssignment.
 * @param node Node to check
 * @throws Error if it is not a property assignment (in a record)
 */
var assertPropertyAssignment = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.PropertyAssignment) {
        throw new Error("Expected PropertyAssignment, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertPropertyAssignment = assertPropertyAssignment;
/**
 * Ensures the given node is an NonNullExpression.
 * @param node Node to check
 * @throws Error if it is not a non-null expression
 */
var assertNonNullExpr = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.NonNullExpression) {
        throw new Error("Expected NonNullExpression, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertNonNullExpr = assertNonNullExpr;
/**
 * Ensures the given node is an JsxElement.
 * @param node Node to check
 * @throws Error if it is not an JSX element
 */
var assertJsxElem = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.JsxElement) {
        throw new Error("Expected JsxElement, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertJsxElem = assertJsxElem;
/**
 * Ensures the given node is an JsxSelfClosingElement.
 * @param node Node to check
 * @throws Error if it is not an JSX self-closing element
 */
var assertJsxSelfClosingElem = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.JsxSelfClosingElement) {
        throw new Error("Expected JsxSelfClosingElement, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertJsxSelfClosingElem = assertJsxSelfClosingElem;
/**
 * Ensures the given node is an JsxFragment.
 * @param node Node to check
 * @throws Error if it is not an JSX fragment
 */
var assertJsxFragment = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.JsxFragment) {
        throw new Error("Expected JsxFragment, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertJsxFragment = assertJsxFragment;
/**
 * Ensures the given node is an JsxExpression.
 * @param node Node to check
 * @throws Error if it is not an JSX expression
 */
var assertJsxExpr = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.JsxExpression) {
        throw new Error("Expected JsxExpression, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertJsxExpr = assertJsxExpr;
/**
 * Ensures the given node is an JsxAttribute.
 * @param node Node to check
 * @throws Error if it is not an JSX attribute
 */
var assertJsxAttribute = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.JsxAttribute) {
        throw new Error("Expected JsxAttribute, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertJsxAttribute = assertJsxAttribute;
/**
 * Ensures the given node is an ArrayBindingPattern.
 * @param node Node to check
 * @throws Error if it is not an array binding pattern
 */
var assertArrayBindingPattern = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.ArrayBindingPattern) {
        throw new Error("Expected ArrayBindingName, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertArrayBindingPattern = assertArrayBindingPattern;
/**
 * Ensures the given node is an BindingElement.
 * @param node Node to check
 * @throws Error if it is not a binding element
 */
var assertBindingElement = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.BindingElement) {
        throw new Error("Expected BindingElement, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertBindingElement = assertBindingElement;
/**
 * Ensures the given node is an ExpressionWithTypeArguments.
 * @param node Node to check
 * @throws Error if it is not an expression with type arguments
 */
var assertExpressionWithTypeArguments = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.ExpressionWithTypeArguments) {
        throw new Error("Expected ExpressionWithTypeArguments, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertExpressionWithTypeArguments = assertExpressionWithTypeArguments;
/**
 * Ensures the given node is an InterfaceDeclaration.
 * @param node Node to check
 * @throws Error if it is not an interface declaration
 */
var assertInterfaceDecl = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.InterfaceDeclaration) {
        throw new Error("Expected InterfaceDeclaration, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertInterfaceDecl = assertInterfaceDecl;
/**
 * Ensures the given node is an ClassDeclaration.
 * @param node Node to check
 * @throws Error if it is not a class declaration
 */
var assertClassDecl = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.ClassDeclaration) {
        throw new Error("Expected ClassDeclaration, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertClassDecl = assertClassDecl;
/**
 * Ensures the given node is an PropertyDeclaration.
 * @param node Node to check
 * @throws Error if it is not a property declaration
 */
var assertPropertyDecl = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.PropertyDeclaration) {
        throw new Error("Expected PropertyDeclaration, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertPropertyDecl = assertPropertyDecl;
/**
 * Ensures the given node is an ConstructorDeclaration.
 * @param node Node to check
 * @throws Error if it is not a constructor declaration
 */
var assertConstructorDecl = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.Constructor) {
        throw new Error("Expected Constructor, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertConstructorDecl = assertConstructorDecl;
/**
 * Ensures the given node is an MethodSignature.
 * @param node Node to check
 * @throws Error if it is not a method signature
 */
var assertMethodSignature = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.MethodSignature) {
        throw new Error("Expected MethodSignature, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertMethodSignature = assertMethodSignature;
/**
 * Ensures the given node is an MethodDeclaration.
 * @param node Node to check
 * @throws Error if it is not a method declaration
 */
var assertMethodDecl = function (node) {
    if (node.kind !== typescript_1.SyntaxKind.MethodDeclaration) {
        throw new Error("Expected MethodDeclaration, got ".concat(typescript_1.SyntaxKind[node.kind]));
    }
    return true;
};
exports.assertMethodDecl = assertMethodDecl;
/** Determines whether the given value is a record. */
var isRecord = function (val) {
    return typeof val === 'object' && val !== null;
};
exports.isRecord = isRecord;
/** Determines whether the given node has a JSDoc comment. */
var hasJSDoc = function (node) {
    return (0, exports.isRecord)(node) && Array.isArray(node.jsDoc) && node.jsDoc.length > 0;
};
exports.hasJSDoc = hasJSDoc;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvdHlwZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLHlDQWtCb0Y7QUFHcEY7Ozs7R0FJRztBQUNJLElBQU0sZ0JBQWdCLEdBQUcsVUFBQyxJQUFVO0lBQ3pDLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyx1QkFBVSxDQUFDLGlCQUFpQixFQUFFO1FBQzlDLE1BQU0sSUFBSSxLQUFLLENBQUMsMENBQW1DLHVCQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFFLENBQUMsQ0FBQztLQUM3RTtJQUNELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQyxDQUFDO0FBTFcsUUFBQSxnQkFBZ0Isb0JBSzNCO0FBRUY7Ozs7R0FJRztBQUNJLElBQU0sbUJBQW1CLEdBQUcsVUFBQyxJQUFVO0lBQzVDLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyx1QkFBVSxDQUFDLG9CQUFvQixFQUFFO1FBQ2pELE1BQU0sSUFBSSxLQUFLLENBQUMsNkNBQXNDLHVCQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFFLENBQUMsQ0FBQztLQUNoRjtJQUNELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQyxDQUFDO0FBTFcsUUFBQSxtQkFBbUIsdUJBSzlCO0FBRUY7Ozs7R0FJRztBQUNJLElBQU0sa0JBQWtCLEdBQUcsVUFBQyxJQUFVO0lBQzNDLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyx1QkFBVSxDQUFDLFlBQVksRUFBRTtRQUN6QyxNQUFNLElBQUksS0FBSyxDQUFDLHlDQUFrQyx1QkFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBRSxDQUFDLENBQUM7S0FDNUU7SUFDRCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUMsQ0FBQztBQUxXLFFBQUEsa0JBQWtCLHNCQUs3QjtBQUVGOzs7O0dBSUc7QUFDSSxJQUFNLG1CQUFtQixHQUFHLFVBQUMsSUFBVTtJQUM1QyxJQUFJ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