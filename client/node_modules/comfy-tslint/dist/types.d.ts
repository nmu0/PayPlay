import { ArrayBindingPattern, ArrayLiteralExpression, ArrayTypeNode, ArrowFunction, BinaryExpression, BindingElement, Block, CallExpression, ClassDeclaration, ConditionalExpression, ConstructorDeclaration, DoStatement, ElementAccessExpression, ExpressionStatement, ExpressionWithTypeArguments, ForStatement, ForInStatement, ForOfStatement, FunctionDeclaration, FunctionExpression, FunctionTypeNode, Identifier, IfStatement, ImportDeclaration, InterfaceDeclaration, IntersectionTypeNode, JsxAttribute, JsxElement, JsxExpression, JsxFragment, JsxSelfClosingElement, LabeledStatement, MethodDeclaration, MethodSignature, NewExpression, Node, NonNullExpression, ObjectLiteralExpression, ParenthesizedExpression, PostfixUnaryExpression, PrefixUnaryExpression, PropertyAccessExpression, PropertyAssignment, PropertyDeclaration, PropertySignature, ReturnStatement, SpreadElement, StringLiteral, SwitchStatement, TemplateExpression, ThrowStatement, TupleTypeNode, TryStatement, TypeAliasDeclaration, TypeLiteralNode, TypeOfExpression, TypeOperatorNode, TypePredicateNode, TypeReferenceNode, UnionTypeNode, VariableStatement, VariableDeclarationList, WhileStatement, WithStatement } from 'typescript';
/**
 * Ensures the given node is an ImportDeclaration.
 * @param node Node to check
 * @throws Error if it is not an import
 */
export declare const assertImportDecl: (node: Node) => node is ImportDeclaration;
/**
 * Ensures the given node is an TypeAliasDeclaration.
 * @param node Node to check
 * @throws Error if it is not a type alias
 */
export declare const assertTypeAliasDecl: (node: Node) => node is TypeAliasDeclaration;
/**
 * Ensures the given node is an TypeOperatorNode.
 * @param node Node to check
 * @throws Error if it is not a type operator
 */
export declare const assertTypeOperator: (node: Node) => node is TypeOperatorNode;
/**
 * Ensures the given node is a TypeReference.
 * @param node Node to check
 * @throws Error if it is not a type reference
 */
export declare const assertTypeReference: (node: Node) => node is TypeReferenceNode;
/**
 * Ensures the given node is an ArrayType.
 * @param node Node to check
 * @throws Error if it is not an array type
 */
export declare const assertArrayType: (node: Node) => node is ArrayTypeNode;
/**
 * Ensures the given node is a TupleType.
 * @param node Node to check
 * @throws Error if it is not a tuple type
 */
export declare const assertTupleType: (node: Node) => node is TupleTypeNode;
/**
 * Ensures the given node is a UnionType.
 * @param node Node to check
 * @throws Error if it is not a union type
 */
export declare const assertUnionType: (node: Node) => node is UnionTypeNode;
/**
 * Ensures the given node is an FunctionType.
 * @param node Node to check
 * @throws Error if it is not a function type
 */
export declare const assertFunctionType: (node: Node) => node is FunctionTypeNode;
/**
 * Ensures the given node is a TypeLiteral.
 * @param node Node to check
 * @throws Error if it is not a type literal (record type)
 */
export declare const assertTypeLiteral: (node: Node) => node is TypeLiteralNode;
/**
 * Ensures the given node is a PropertySignature.
 * @param node Node to check
 * @throws Error if it is not a property signature
 */
export declare const assertPropertySignature: (node: Node) => node is PropertySignature;
/**
 * Ensures the given node is a TypePredicate.
 * @param node Node to check
 * @throws Error if it is not a type literal (record type)
 */
export declare const assertTypePredicate: (node: Node) => node is TypePredicateNode;
/**
 * Ensures the given node is a TypeIntersection.
 * @param node Node to check
 * @throws Error if it is not a type literal (record type)
 */
export declare const assertIntersectionType: (node: Node) => node is IntersectionTypeNode;
/**
 * Ensures the given node is an ArrowFunction.
 * @param node Node to check
 * @throws Error if it is not an arrow function
 */
export declare const assertArrowFunction: (node: Node) => node is ArrowFunction;
/**
 * Ensures the given node is a FunctionExpression.
 * @param node Node to check
 * @throws Error if it is not a function expression
 */
export declare const assertFunctionExpression: (node: Node) => node is FunctionExpression;
/**
 * Ensures the given node is a block.
 * @param node Node to check
 * @throws Error if it is not a block
 */
export declare const assertBlock: (node: Node) => node is Block;
/**
 * Ensures the given node is an Identifier.
 * @param node Node to check
 * @throws Error if it is not an identifier
 */
export declare const assertIdentifier: (node: Node) => node is Identifier;
/**
 * Ensures the given node is a StringLiteral.
 * @param node Node to check
 * @throws Error if it is not a string literal
 */
export declare const assertStringLiteral: (node: Node) => node is StringLiteral;
/**
 * Ensures the given node is a FunctionDeclaration.
 * @param node Node to check
 * @throws Error if it is not a function declaration
 */
export declare const assertFunctionDecl: (node: Node) => node is FunctionDeclaration;
/**
 * Ensures the given node is an VariableDeclarationList.
 * @param node Node to check
 * @throws Error if it is not a variable declaration list
 */
export declare const assertVariableDeclList: (node: Node) => node is VariableDeclarationList;
/**
 * Ensures the given node is an VariableStatement.
 * @param node Node to check
 * @throws Error if it is not a variable statement
 */
export declare const assertVariableStmt: (node: Node) => node is VariableStatement;
/**
 * Ensures the given node is an IfStatement.
 * @param node Node to check
 * @throws Error if it is not an if statement
 */
export declare const assertIfStmt: (node: Node) => node is IfStatement;
/**
 * Ensures the given node is an ExpressionStatement.
 * @param node Node to check
 * @throws Error if it is not an expression statement
 */
export declare const assertExpressionStmt: (node: Node) => node is ExpressionStatement;
/**
 * Ensures the given node is an SwitchStatement.
 * @param node Node to check
 * @throws Error if it is not a switch statement
 */
export declare const assertSwitchStmt: (node: Node) => node is SwitchStatement;
/**
 * Ensures the given node is an DoStatement.
 * @param node Node to check
 * @throws Error if it is not a do statement
 */
export declare const assertDoStmt: (node: Node) => node is DoStatement;
/**
 * Ensures the given node is an ForStatement.
 * @param node Node to check
 * @throws Error if it is not a for statement
 */
export declare const assertForStmt: (node: Node) => node is ForStatement;
/**
 * Ensures the given node is an ForInStatement.
 * @param node Node to check
 * @throws Error if it is not a for-in statement
 */
export declare const assertForInStmt: (node: Node) => node is ForInStatement;
/**
 * Ensures the given node is an ForOfStatement.
 * @param node Node to check
 * @throws Error if it is not a for-of statement
 */
export declare const assertForOfStmt: (node: Node) => node is ForOfStatement;
/**
 * Ensures the given node is an WhileStatement.
 * @param node Node to check
 * @throws Error if it is not a while statement
 */
export declare const assertWhileStmt: (node: Node) => node is WhileStatement;
/**
 * Ensures the given node is an WithStatement.
 * @param node Node to check
 * @throws Error if it is not a with statement
 */
export declare const assertWithStmt: (node: Node) => node is WithStatement;
/**
 * Ensures the given node is an LabeledStatement.
 * @param node Node to check
 * @throws Error if it is not a labeled statement
 */
export declare const assertLabeledStmt: (node: Node) => node is LabeledStatement;
/**
 * Ensures the given node is an ReturnStatement.
 * @param node Node to check
 * @throws Error if it is not a return statement
 */
export declare const assertReturnStmt: (node: Node) => node is ReturnStatement;
/**
 * Ensures the given node is an ThrowStatement.
 * @param node Node to check
 * @throws Error if it is not a throw statement
 */
export declare const assertThrowStmt: (node: Node) => node is ThrowStatement;
/**
 * Ensures the given node is an TryStatement.
 * @param node Node to check
 * @throws Error if it is not a try statement
 */
export declare const assertTryStmt: (node: Node) => node is TryStatement;
/**
 * Ensures the given node is an ParenthesizedExpression.
 * @param node Node to check
 * @throws Error if it is not a parenthesized expression
 */
export declare const assertParenthesizedExpr: (node: Node) => node is ParenthesizedExpression;
/**
 * Ensures the given node is an PrefixUnaryExpression.
 * @param node Node to check
 * @throws Error if it is not a (prefix) unary expression
 */
export declare const assertPrefixUnaryExpr: (node: Node) => node is PrefixUnaryExpression;
/**
 * Ensures the given node is an PostfixUnaryExpression.
 * @param node Node to check
 * @throws Error if it is not a (postfix) unary expression
 */
export declare const assertPostfixUnaryExpr: (node: Node) => node is PostfixUnaryExpression;
/**
 * Ensures the given node is an BinaryExpression.
 * @param node Node to check
 * @throws Error if it is not a binary expression
 */
export declare const assertBinaryExpr: (node: Node) => node is BinaryExpression;
/**
 * Ensures the given node is an ConditionalExpression.
 * @param node Node to check
 * @throws Error if it is not a conditional expression
 */
export declare const assertConditionalExpr: (node: Node) => node is ConditionalExpression;
/**
 * Ensures the given node is an TypeOfExpression.
 * @param node Node to check
 * @throws Error if it is not a type-of expression
 */
export declare const assertTypeOfExpr: (node: Node) => node is TypeOfExpression;
/**
 * Ensures the given node is an SpreadElement.
 * @param node Node to check
 * @throws Error if it is not a spread element
 */
export declare const assertSpreadElement: (node: Node) => node is SpreadElement;
/**
 * Ensures the given node is an PropertyAccessExpression.
 * @param node Node to check
 * @throws Error if it is not a property access expression
 */
export declare const assertPropertyAccessExpr: (node: Node) => node is PropertyAccessExpression;
/**
 * Ensures the given node is an ElementAccessExpression.
 * @param node Node to check
 * @throws Error if it is not a element access expression
 */
export declare const assertElementAccessExpr: (node: Node) => node is ElementAccessExpression;
/**
 * Ensures the given node is an CallExpression.
 * @param node Node to check
 * @throws Error if it is not a call expression
 */
export declare const assertCallExpr: (node: Node) => node is CallExpression;
/**
 * Ensures the given node is an NewExpression.
 * @param node Node to check
 * @throws Error if it is not a new expression
 */
export declare const assertNewExpr: (node: Node) => node is NewExpression;
/**
 * Ensures the given node is an TemplateExpression.
 * @param node Node to check
 * @throws Error if it is not a template literal expression
 */
export declare const assertTemplateExpr: (node: Node) => node is TemplateExpression;
/**
 * Ensures the given node is an ArrayLiteralExpression.
 * @param node Node to check
 * @throws Error if it is not an array literal expression
 */
export declare const assertArrayLiteralExpr: (node: Node) => node is ArrayLiteralExpression;
/**
 * Ensures the given node is an ObjectLiteralExpression.
 * @param node Node to check
 * @throws Error if it is not an object literal expression
 */
export declare const assertObjectLiteralExpr: (node: Node) => node is ObjectLiteralExpression;
/**
 * Ensures the given node is an PropertyAssignment.
 * @param node Node to check
 * @throws Error if it is not a property assignment (in a record)
 */
export declare const assertPropertyAssignment: (node: Node) => node is PropertyAssignment;
/**
 * Ensures the given node is an NonNullExpression.
 * @param node Node to check
 * @throws Error if it is not a non-null expression
 */
export declare const assertNonNullExpr: (node: Node) => node is NonNullExpression;
/**
 * Ensures the given node is an JsxElement.
 * @param node Node to check
 * @throws Error if it is not an JSX element
 */
export declare const assertJsxElem: (node: Node) => node is JsxElement;
/**
 * Ensures the given node is an JsxSelfClosingElement.
 * @param node Node to check
 * @throws Error if it is not an JSX self-closing element
 */
export declare const assertJsxSelfClosingElem: (node: Node) => node is JsxSelfClosingElement;
/**
 * Ensures the given node is an JsxFragment.
 * @param node Node to check
 * @throws Error if it is not an JSX fragment
 */
export declare const assertJsxFragment: (node: Node) => node is JsxFragment;
/**
 * Ensures the given node is an JsxExpression.
 * @param node Node to check
 * @throws Error if it is not an JSX expression
 */
export declare const assertJsxExpr: (node: Node) => node is JsxExpression;
/**
 * Ensures the given node is an JsxAttribute.
 * @param node Node to check
 * @throws Error if it is not an JSX attribute
 */
export declare const assertJsxAttribute: (node: Node) => node is JsxAttribute;
/**
 * Ensures the given node is an ArrayBindingPattern.
 * @param node Node to check
 * @throws Error if it is not an array binding pattern
 */
export declare const assertArrayBindingPattern: (node: Node) => node is ArrayBindingPattern;
/**
 * Ensures the given node is an BindingElement.
 * @param node Node to check
 * @throws Error if it is not a binding element
 */
export declare const assertBindingElement: (node: Node) => node is BindingElement;
/**
 * Ensures the given node is an ExpressionWithTypeArguments.
 * @param node Node to check
 * @throws Error if it is not an expression with type arguments
 */
export declare const assertExpressionWithTypeArguments: (node: Node) => node is ExpressionWithTypeArguments;
/**
 * Ensures the given node is an InterfaceDeclaration.
 * @param node Node to check
 * @throws Error if it is not an interface declaration
 */
export declare const assertInterfaceDecl: (node: Node) => node is InterfaceDeclaration;
/**
 * Ensures the given node is an ClassDeclaration.
 * @param node Node to check
 * @throws Error if it is not a class declaration
 */
export declare const assertClassDecl: (node: Node) => node is ClassDeclaration;
/**
 * Ensures the given node is an PropertyDeclaration.
 * @param node Node to check
 * @throws Error if it is not a property declaration
 */
export declare const assertPropertyDecl: (node: Node) => node is PropertyDeclaration;
/**
 * Ensures the given node is an ConstructorDeclaration.
 * @param node Node to check
 * @throws Error if it is not a constructor declaration
 */
export declare const assertConstructorDecl: (node: Node) => node is ConstructorDeclaration;
/**
 * Ensures the given node is an MethodSignature.
 * @param node Node to check
 * @throws Error if it is not a method signature
 */
export declare const assertMethodSignature: (node: Node) => node is MethodSignature;
/**
 * Ensures the given node is an MethodDeclaration.
 * @param node Node to check
 * @throws Error if it is not a method declaration
 */
export declare const assertMethodDecl: (node: Node) => node is MethodDeclaration;
/** Determines whether the given value is a record. */
export declare const isRecord: (val: unknown) => val is Record<string, unknown>;
/** Determines whether the given node has a JSDoc comment. */
export declare const hasJSDoc: (node: Node) => boolean;
